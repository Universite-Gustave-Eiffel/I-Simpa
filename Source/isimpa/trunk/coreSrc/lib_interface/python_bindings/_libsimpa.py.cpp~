/* ----------------------------------------------------------------------
* I-SIMPA (http://i-simpa.ifsttar.fr). This file is part of I-SIMPA.
*
* I-SIMPA is a GUI for 3D numerical sound propagation modelling dedicated
* to scientific acoustic simulations.
* Copyright (C) 2007-2014 - IFSTTAR - Judicael Picaut, Nicolas Fortin
*
* I-SIMPA is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 3 of the License, or
* (at your option) any later version.
* 
* I-SIMPA is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software Foundation,
* Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA or 
* see <http://ww.gnu.org/licenses/>
*
* For more information, please consult: <http://i-simpa.ifsttar.fr> or 
* send an email to i-simpa@ifsttar.fr
*
* To contact Ifsttar, write to Ifsttar, 14-20 Boulevard Newton
* Cite Descartes, Champs sur Marne F-77447 Marne la Vallee Cedex 2 FRANCE
* or write to scientific.computing@ifsttar.fr
* ----------------------------------------------------------------------*/

// This file has been generated by Py++.

#include "boost/python.hpp"

#include "__array_1.pypp.hpp"

#include "__convenience.pypp.hpp"

#include "__call_policies.pypp.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "dummy.hpp"

namespace bp = boost::python;

struct bintetraface_wrapper : formatMBIN::bintetraface, bp::wrapper< formatMBIN::bintetraface > {

    bintetraface_wrapper(formatMBIN::bintetraface const & arg )
    : formatMBIN::bintetraface( arg )
      , bp::wrapper< formatMBIN::bintetraface >(){
        // copy constructor
        
    }

    bintetraface_wrapper()
    : formatMBIN::bintetraface()
      , bp::wrapper< formatMBIN::bintetraface >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< int, 3>
    pyplusplus_sommets_wrapper( ::formatMBIN::bintetraface & inst ){
        return pyplusplus::containers::static_sized::array_1_t< int, 3>( inst.sommets );
    }

};

struct bintetrahedre_wrapper : formatMBIN::bintetrahedre, bp::wrapper< formatMBIN::bintetrahedre > {

    bintetrahedre_wrapper(formatMBIN::bintetrahedre const & arg )
    : formatMBIN::bintetrahedre( arg )
      , bp::wrapper< formatMBIN::bintetrahedre >(){
        // copy constructor
        
    }

    bintetrahedre_wrapper()
    : formatMBIN::bintetrahedre()
      , bp::wrapper< formatMBIN::bintetrahedre >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< int, 4>
    pyplusplus_sommets_wrapper( ::formatMBIN::bintetrahedre & inst ){
        return pyplusplus::containers::static_sized::array_1_t< int, 4>( inst.sommets );
    }

    static pyplusplus::containers::static_sized::array_1_t< ::formatMBIN::bintetraface, 4>
    pyplusplus_tetrafaces_wrapper( ::formatMBIN::bintetrahedre & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::formatMBIN::bintetraface, 4>( inst.tetrafaces );
    }

};

struct t_binNode_wrapper : formatMBIN::t_binNode, bp::wrapper< formatMBIN::t_binNode > {

    t_binNode_wrapper(formatMBIN::t_binNode const & arg )
    : formatMBIN::t_binNode( arg )
      , bp::wrapper< formatMBIN::t_binNode >(){
        // copy constructor
        
    }

    t_binNode_wrapper( )
    : formatMBIN::t_binNode( )
      , bp::wrapper< formatMBIN::t_binNode >(){
        // null constructor
    
    }

    t_binNode_wrapper(::formatMBIN::Floatb const & x, ::formatMBIN::Floatb const & y, ::formatMBIN::Floatb const & z )
    : formatMBIN::t_binNode( x, y, z )
      , bp::wrapper< formatMBIN::t_binNode >(){
        // constructor
    
    }

    static pyplusplus::containers::static_sized::array_1_t< float, 3>
    pyplusplus_node_wrapper( ::formatMBIN::t_binNode & inst ){
        return pyplusplus::containers::static_sized::array_1_t< float, 3>( inst.node );
    }

};

static boost::python::tuple GetFaceEnergy_55c09b76319b542d67de8263861c1e72( ::formatRSBIN::rsurf_data const & inst, ::size_t const & rsIndex, ::size_t const & faceIndex, ::size_t const & recordIndex ){
    unsigned int idstep2;
    float energy2;
    inst.GetFaceEnergy(rsIndex, faceIndex, recordIndex, idstep2, energy2);
    return bp::make_tuple( idstep2, energy2 );
}

static boost::python::tuple GetFaceInfo_ffd41391329802f344cde7ce4f2494dc( ::formatRSBIN::rsurf_data const & inst, ::size_t const & rsIndex, ::size_t const & faceIndex ){
    unsigned int vertexA2;
    unsigned int vertexB2;
    unsigned int vertexC2;
    unsigned int recordCount2;
    inst.GetFaceInfo(rsIndex, faceIndex, vertexA2, vertexB2, vertexC2, recordCount2);
    return bp::make_tuple( vertexA2, vertexB2, vertexC2, recordCount2 );
}

static boost::python::tuple GetFileInfos_525a3be9f8f575bd95315a87170ba40a( ::formatRSBIN::rsurf_data const & inst ){
    unsigned int rs_size2;
    unsigned int nodes_size2;
    unsigned int nbtimestep2;
    float timestep2;
    std::basic_string<char,std::char_traits<char>,std::allocator<char> > recordType2;
    inst.GetFileInfos(rs_size2, nodes_size2, nbtimestep2, timestep2, recordType2);
    return bp::make_tuple( rs_size2, nodes_size2, nbtimestep2, timestep2, recordType2 );
}

static boost::python::tuple GetNodePositionValue_69e14843c7ed97ad3f492e0c41cf7a26( ::formatRSBIN::rsurf_data const & inst, ::size_t const & nodeIndex ){
    float x2;
    float y2;
    float z2;
    inst.GetNodePositionValue(nodeIndex, x2, y2, z2);
    return bp::make_tuple( x2, y2, z2 );
}

static boost::python::tuple GetRsInfo_a448d76a66bcf1e5144f7f8c9f8afdd9( ::formatRSBIN::rsurf_data const & inst, ::size_t const & rsIndex ){
    unsigned int nbfaces2;
    std::basic_string<char,std::char_traits<char>,std::allocator<char> > rs_name2;
    int xmlid2;
    inst.GetRsInfo(rsIndex, nbfaces2, rs_name2, xmlid2);
    return bp::make_tuple( nbfaces2, rs_name2, xmlid2 );
}

static boost::python::object GetIsoLevelCurves_0b820db76235dcaa6b487d6859dceb78( ::formatRSBIN::rsurf_iso_contouring & inst, float const & isolvl ){
    std::list<formatRSBIN::t_curve,std::allocator<formatRSBIN::t_curve> > curvlst2;
    inst.GetIsoLevelCurves(isolvl, curvlst2);
    return bp::object( curvlst2 );
}

static boost::python::tuple GetMinMax_e4c8ac6649065b317c0a2384fc05fbe2( ::formatRSBIN::rsurf_iso_contouring & inst ){
    float min2;
    float max2;
    inst.GetMinMax(min2, max2);
    return bp::make_tuple( min2, max2 );
}

struct t_curve_wrapper : formatRSBIN::t_curve, bp::wrapper< formatRSBIN::t_curve > {

    t_curve_wrapper(formatRSBIN::t_curve const & arg )
    : formatRSBIN::t_curve( arg )
      , bp::wrapper< formatRSBIN::t_curve >(){
        // copy constructor
        
    }

    t_curve_wrapper()
    : formatRSBIN::t_curve()
      , bp::wrapper< formatRSBIN::t_curve >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< float, 3>
    pyplusplus_A_wrapper( ::formatRSBIN::t_curve & inst ){
        return pyplusplus::containers::static_sized::array_1_t< float, 3>( inst.A );
    }

    static pyplusplus::containers::static_sized::array_1_t< float, 3>
    pyplusplus_B_wrapper( ::formatRSBIN::t_curve & inst ){
        return pyplusplus::containers::static_sized::array_1_t< float, 3>( inst.B );
    }

};

static boost::python::object ReadColFloat_2d7d953196ad1599f64a7b62cd706458( ::gabe_io::Gabe_rw & inst, ::size_t const & idcol ){
    std::vector<float, std::allocator<float> > coldata2;
    inst.ReadColFloat(idcol, coldata2);
    return bp::object( coldata2 );
}

static boost::python::object ReadColInt_a923d984c4b477c9ce588113f8089b93( ::gabe_io::Gabe_rw & inst, ::size_t const & idcol ){
    std::vector<int, std::allocator<int> > coldata2;
    inst.ReadColInt(idcol, coldata2);
    return bp::object( coldata2 );
}

static boost::python::object ReadColStr_0f0439e36e04578028500fb87bbc9ea3( ::gabe_io::Gabe_rw & inst, ::size_t const & idcol ){
    std::vector<std::string, std::allocator<std::string> > coldata2;
    inst.ReadColStr(idcol, coldata2);
    return bp::object( coldata2 );
}

static boost::python::tuple GetHeaderData_22ac753966e05a8aaaebdeb7d63f0bed( ::particleio::ParticuleIO & inst ){
    float timeStep2;
    long unsigned int nbParticles2;
    long unsigned int nbStepMax2;
    inst.GetHeaderData(timeStep2, nbParticles2, nbStepMax2);
    return bp::make_tuple( timeStep2, nbParticles2, nbStepMax2 );
}

static boost::python::tuple NextParticle_3634bdc7fe706d56792b926e84e164fb( ::particleio::ParticuleIO & inst ){
    long unsigned int firstTimeStep2;
    long unsigned int nbTimeStep2;
    inst.NextParticle(firstTimeStep2, nbTimeStep2);
    return bp::make_tuple( firstTimeStep2, nbTimeStep2 );
}

static boost::python::tuple NextTimeStep_5264ddf1ca6388c651910d6ab7422e21( ::particleio::ParticuleIO & inst ){
    float x2;
    float y2;
    float z2;
    float energy2;
    inst.NextTimeStep(x2, y2, z2, energy2);
    return bp::make_tuple( x2, y2, z2, energy2 );
}

static boost::python::object GetGroupInformation_473f95957775c7bfc40d6c2fd58b23d3( ::surf_merge::SurfaceMerging & inst, unsigned int const & idel ){
    std::vector<unsigned int,std::allocator<unsigned int> > faceIds2;
    inst.GetGroupInformation(idel, faceIds2);
    return bp::object( faceIds2 );
}

static boost::python::object GetInternalFaces_fbc0fddf6ae8bebef1d097a04f650254( ::volumes_splitter::VolumesSplitter & inst, int const & volumeXmlIdFilter=-0x000000001 ){
    std::vector<unsigned int,std::allocator<unsigned int> > internalFaceIds2;
    inst.GetInternalFaces(internalFaceIds2, volumeXmlIdFilter);
    return bp::object( internalFaceIds2 );
}

static boost::python::tuple GetVolumeInformation_1c18ff1b84a2763e89ab8ac465e1d8ad( ::volumes_splitter::VolumesSplitter & inst, int const & idel ){
    int volumeXmlId2;
    double volume2;
    std::vector<unsigned int,std::allocator<unsigned int> > faceIds2;
    std::vector<unsigned int,std::allocator<unsigned int> > volNeigh2;
    inst.GetVolumeInformation(idel, volumeXmlId2, volume2, faceIds2, volNeigh2);
    return bp::make_tuple( volumeXmlId2, volume2, faceIds2, volNeigh2 );
}

BOOST_PYTHON_MODULE(_libsimpa){
    bp::class_< std::vector< unsigned int > >("vector_less__unsigned_int__greater_")    
        .def( bp::vector_indexing_suite< ::std::vector< unsigned int >, true >() );

    { //::std::vector< std::string >
        typedef bp::class_< std::vector< std::string > > stringarray_exposer_t;
        stringarray_exposer_t stringarray_exposer = stringarray_exposer_t( "stringarray" );
        bp::scope stringarray_scope( stringarray_exposer );
        stringarray_exposer.def( bp::vector_indexing_suite< ::std::vector< std::string >, true >() );
    }

    { //::std::vector< int >
        typedef bp::class_< std::vector< int > > intarray_exposer_t;
        intarray_exposer_t intarray_exposer = intarray_exposer_t( "intarray" );
        bp::scope intarray_scope( intarray_exposer );
        intarray_exposer.def( bp::vector_indexing_suite< ::std::vector< int >, true >() );
    }

    { //::std::vector< formatMBIN::t_binNode >
        typedef bp::class_< std::vector< formatMBIN::t_binNode > > vector_less__formatMBIN_scope_t_binNode__greater__exposer_t;
        vector_less__formatMBIN_scope_t_binNode__greater__exposer_t vector_less__formatMBIN_scope_t_binNode__greater__exposer = vector_less__formatMBIN_scope_t_binNode__greater__exposer_t( "vector_less__formatMBIN_scope_t_binNode__greater_" );
        bp::scope vector_less__formatMBIN_scope_t_binNode__greater__scope( vector_less__formatMBIN_scope_t_binNode__greater__exposer );
        vector_less__formatMBIN_scope_t_binNode__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< formatMBIN::t_binNode > >() );
    }

    { //::std::vector< formatMBIN::bintetrahedre >
        typedef bp::class_< std::vector< formatMBIN::bintetrahedre > > vector_less__formatMBIN_scope_bintetrahedre__greater__exposer_t;
        vector_less__formatMBIN_scope_bintetrahedre__greater__exposer_t vector_less__formatMBIN_scope_bintetrahedre__greater__exposer = vector_less__formatMBIN_scope_bintetrahedre__greater__exposer_t( "vector_less__formatMBIN_scope_bintetrahedre__greater_" );
        bp::scope vector_less__formatMBIN_scope_bintetrahedre__greater__scope( vector_less__formatMBIN_scope_bintetrahedre__greater__exposer );
        vector_less__formatMBIN_scope_bintetrahedre__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< formatMBIN::bintetrahedre > >() );
    }

    bp::class_< std::vector< formatGABE::GABE_OBJECTTYPE > >("vector_less__formatGABE_scope_GABE_OBJECTTYPE__greater_")    
        .def( bp::vector_indexing_suite< ::std::vector< formatGABE::GABE_OBJECTTYPE >, true >() );

    { //::std::vector< formatCoreBIN::t_pos >
        typedef bp::class_< std::vector< formatCoreBIN::t_pos > > vector_less__formatCoreBIN_scope_t_pos__greater__exposer_t;
        vector_less__formatCoreBIN_scope_t_pos__greater__exposer_t vector_less__formatCoreBIN_scope_t_pos__greater__exposer = vector_less__formatCoreBIN_scope_t_pos__greater__exposer_t( "vector_less__formatCoreBIN_scope_t_pos__greater_" );
        bp::scope vector_less__formatCoreBIN_scope_t_pos__greater__scope( vector_less__formatCoreBIN_scope_t_pos__greater__exposer );
        vector_less__formatCoreBIN_scope_t_pos__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< formatCoreBIN::t_pos > >() );
    }

    { //::std::vector< formatCoreBIN::ioFace >
        typedef bp::class_< std::vector< formatCoreBIN::ioFace > > vector_less__formatCoreBIN_scope_ioFace__greater__exposer_t;
        vector_less__formatCoreBIN_scope_ioFace__greater__exposer_t vector_less__formatCoreBIN_scope_ioFace__greater__exposer = vector_less__formatCoreBIN_scope_ioFace__greater__exposer_t( "vector_less__formatCoreBIN_scope_ioFace__greater_" );
        bp::scope vector_less__formatCoreBIN_scope_ioFace__greater__scope( vector_less__formatCoreBIN_scope_ioFace__greater__exposer );
        vector_less__formatCoreBIN_scope_ioFace__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< formatCoreBIN::ioFace > >() );
    }

    { //::std::vector< float >
        typedef bp::class_< std::vector< float > > floatarray_exposer_t;
        floatarray_exposer_t floatarray_exposer = floatarray_exposer_t( "floatarray" );
        bp::scope floatarray_scope( floatarray_exposer );
        floatarray_exposer.def( bp::vector_indexing_suite< ::std::vector< float >, true >() );
    }

    bp::enum_< formatGABE::GABE_OBJECTTYPE>("GABE_OBJECTTYPE")
        .value("GABE_OBJECTTYPE_USER_DEFINED", formatGABE::GABE_OBJECTTYPE_USER_DEFINED)
        .value("GABE_OBJECTTYPE_FLOAT", formatGABE::GABE_OBJECTTYPE_FLOAT)
        .value("GABE_OBJECTTYPE_INT", formatGABE::GABE_OBJECTTYPE_INT)
        .value("GABE_OBJECTTYPE_SHORTSTRING", formatGABE::GABE_OBJECTTYPE_SHORTSTRING)
        .export_values()
        ;

    bp::class_< CalculsGenerauxThermodynamique::CCalculsGenerauxThermodynamique >( "CCalculsGenerauxThermodynamique", "" )    
        .def( 
            "Coef_Att_Atmos"
            , (double (*)( double,double,double,double ))( &::CalculsGenerauxThermodynamique::CCalculsGenerauxThermodynamique::Coef_Att_Atmos )
            , ( bp::arg("F"), bp::arg("H"), bp::arg("P"), bp::arg("K") )
            , "" )    
        .def( 
            "c_son"
            , (double (*)( double ))( &::CalculsGenerauxThermodynamique::CCalculsGenerauxThermodynamique::c_son )
            , ( bp::arg("x") )
            , "" )    
        .def( 
            "masse_vol"
            , (double (*)( double,double ))( &::CalculsGenerauxThermodynamique::CCalculsGenerauxThermodynamique::masse_vol )
            , ( bp::arg("P"), bp::arg("K") )
            , "" )    
        .staticmethod( "Coef_Att_Atmos" )    
        .staticmethod( "c_son" )    
        .staticmethod( "masse_vol" );

    bp::class_< formatCoreBIN::CformatBIN >( "CformatBIN", "", bp::init< >("Constructeur\n") )    
        .def( 
            "ExportBIN"
            , (bool ( ::formatCoreBIN::CformatBIN::* )( char const *,::formatCoreBIN::ioModel & ) )( &::formatCoreBIN::CformatBIN::ExportBIN )
            , ( bp::arg("strFileName"), bp::arg("modelExport") )
            , "Méthode dexportation dun modèle 3D\nParam: strFileName Chemin du fichier\nParam: modelExport Modèle à exporter, déjà converti par coordsOperation::GlCoordsToCommonCoords() .\nParam: matFacesAssociations Lien entre les faces et les materiaux.\nRetourne Vrai si lopération a réussi\n" )    
        .def( 
            "GetSurfAire"
            , (float ( ::formatCoreBIN::CformatBIN::* )( ::formatCoreBIN::ioModel const &,int const & ) )( &::formatCoreBIN::CformatBIN::GetSurfAire )
            , ( bp::arg("model"), bp::arg("indiceface") )
            , "Retourne laire de la surface\n" )    
        .def( 
            "ImportBIN"
            , (bool ( ::formatCoreBIN::CformatBIN::* )( ::formatCoreBIN::ioModel &,char const * ) )( &::formatCoreBIN::CformatBIN::ImportBIN )
            , ( bp::arg("modelImport"), bp::arg("strFileName") )
            , "Méthode dimportation dun fichier binaire\nParam: modelImport Structure de données où stocker le modèle à charger\nParam: strFileName Chemin du fichier\nRetourne Vrai si lopération a réussi\n" );

    bp::class_< formatCoreBIN::ioFace >( "ioFace", "Structure dune face, déstiné à lechange fichier<->CObjet3D\n" )    
        .def( bp::self == bp::self )    
        .def_readwrite( "a", &formatCoreBIN::ioFace::a, "" )    
        .def_readwrite( "b", &formatCoreBIN::ioFace::b, "Structure dune face, déstiné à lechange fichier<->CObjet3D\nstruct ioFace {\nint operator==(const ioFace &_f) {\nreturn a==_f.a && b==_f.b && c==_f.c && idMat==_f.idMat && idRs==_f.idRs && idEn==_f.idEn;\n}\nindiceV a;<  Indice du sommet \n" )    
        .def_readwrite( "c", &formatCoreBIN::ioFace::c, "Structure dune face, déstiné à lechange fichier<->CObjet3D\nstruct ioFace {\nint operator==(const ioFace &_f) {\nreturn a==_f.a && b==_f.b && c==_f.c && idMat==_f.idMat && idRs==_f.idRs && idEn==_f.idEn;\n}\nindiceV a;<  Indice du sommet \nindiceV b;<  Indice du sommet \n" )    
        .def_readwrite( "idEn", &formatCoreBIN::ioFace::idEn, "Structure dune face, déstiné à lechange fichier<->CObjet3D\nstruct ioFace {\nint operator==(const ioFace &_f) {\nreturn a==_f.a && b==_f.b && c==_f.c && idMat==_f.idMat && idRs==_f.idRs && idEn==_f.idEn;\n}\nindiceV a;<  Indice du sommet \nindiceV b;<  Indice du sommet \nindiceV c; <  Indice du sommet \nindiceMat idMat;  < Identifiant du matériau associé à la face (aucun 0) \nindiceRS idRs; < Identifiant du récepteur surfacique (aucun -1) \n" )    
        .def_readwrite( "idMat", &formatCoreBIN::ioFace::idMat, "Structure dune face, déstiné à lechange fichier<->CObjet3D\nstruct ioFace {\nint operator==(const ioFace &_f) {\nreturn a==_f.a && b==_f.b && c==_f.c && idMat==_f.idMat && idRs==_f.idRs && idEn==_f.idEn;\n}\nindiceV a;<  Indice du sommet \nindiceV b;<  Indice du sommet \nindiceV c; <  Indice du sommet \n" )    
        .def_readwrite( "idRs", &formatCoreBIN::ioFace::idRs, "Structure dune face, déstiné à lechange fichier<->CObjet3D\nstruct ioFace {\nint operator==(const ioFace &_f) {\nreturn a==_f.a && b==_f.b && c==_f.c && idMat==_f.idMat && idRs==_f.idRs && idEn==_f.idEn;\n}\nindiceV a;<  Indice du sommet \nindiceV b;<  Indice du sommet \nindiceV c; <  Indice du sommet \nindiceMat idMat;  < Identifiant du matériau associé à la face (aucun 0) \n" );

    bp::class_< formatCoreBIN::ioModel >( "ioModel", "Structure du modèle, déstiné à lechange fichier<->CObjet3D\n" )    
        .def_readwrite( "faces", &formatCoreBIN::ioModel::faces, "" )    
        .def_readwrite( "vertices", &formatCoreBIN::ioModel::vertices, "Structure du modèle, déstiné à lechange fichier<->CObjet3D\nstruct ioModel {\nstd::vector<ioFace> faces; < Faces de la scène \n" );

    bp::class_< formatCoreBIN::t_pos >( "t_pos", "", bp::init< float, float, float >(( bp::arg("_x"), bp::arg("_y"), bp::arg("_z") ), "") )    
        .def_readwrite( "x", &formatCoreBIN::t_pos::x, "" )    
        .def_readwrite( "y", &formatCoreBIN::t_pos::y, "" )    
        .def_readwrite( "z", &formatCoreBIN::t_pos::z, "" )    
        .def( bp::self == bp::self )    
        .def( 
            "__getitem__"
            , (float const & ( ::formatCoreBIN::t_pos::* )( int ) const)( &::formatCoreBIN::t_pos::operator[] )
            , ( bp::arg("_i") )
            , bp::return_value_policy< bp::copy_const_reference >()
            , "" );

    bp::class_< formatMBIN::CMBIN >( "CMBIN", "", bp::init< >("Constructeur\n") )    
        .def( 
            "ComputeVolume"
            , (double (*)( ::formatMBIN::trimeshmodel & ))( &::formatMBIN::CMBIN::ComputeVolume )
            , ( bp::arg("trimesh") )
            , "Calcul la somme des volumes des tetrahèdre contenu de le modèle\nRetourne Volume m3\n" )    
        .def( 
            "LoadMesh"
            , (::formatMBIN::trimeshmodel ( ::formatMBIN::CMBIN::* )( char const * ) )( &::formatMBIN::CMBIN::LoadMesh )
            , ( bp::arg("strFileName") )
            , "@endcond\nMéthode dimportation dun fichier binaire\nParam: strFileName Chemin du fichier\nRetourne Le maillage\n" )    
        .def( 
            "SaveMesh"
            , (void ( ::formatMBIN::CMBIN::* )( char const *,::formatMBIN::trimeshmodel & ) )( &::formatMBIN::CMBIN::SaveMesh )
            , ( bp::arg("strFileName"), bp::arg("trimesh") )
            , "Méthode dexportation dun fichier binaire\nParam: strFileName Chemin du fichier\nParam: trimesh Le maillage\n" )    
        .staticmethod( "ComputeVolume" );

    { //::formatMBIN::bintetraface
        typedef bp::class_< bintetraface_wrapper > bintetraface_exposer_t;
        bintetraface_exposer_t bintetraface_exposer = bintetraface_exposer_t( "bintetraface", "" );
        bp::scope bintetraface_scope( bintetraface_exposer );
        bintetraface_exposer.def_readwrite( "marker", &formatMBIN::bintetraface::marker, "" );
        bintetraface_exposer.def_readwrite( "neighboor", &formatMBIN::bintetraface::neighboor, "Structure dune face dun tetrahedre\nstruct bintetraface\n{\nIntb sommets[3];\nIntb marker;	< Face du modèle -1 aucune \n" );
        pyplusplus::containers::static_sized::register_array_1< int, 3 >( "__array_1_int_3" );
        { //formatMBIN::bintetraface::sommets [variable], type=formatMBIN::Intb[3]
        
            typedef pyplusplus::containers::static_sized::array_1_t< int, 3> ( *array_wrapper_creator )( ::formatMBIN::bintetraface & );
            
            bintetraface_exposer.add_property( "sommets"
                , bp::make_function( array_wrapper_creator(&bintetraface_wrapper::pyplusplus_sommets_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() )
            , "" );
        }
    }

    { //::formatMBIN::bintetrahedre
        typedef bp::class_< bintetrahedre_wrapper > bintetrahedre_exposer_t;
        bintetrahedre_exposer_t bintetrahedre_exposer = bintetrahedre_exposer_t( "bintetrahedre", "" );
        bp::scope bintetrahedre_scope( bintetrahedre_exposer );
        bintetrahedre_exposer.def( bp::self == bp::self );
        bintetrahedre_exposer.def_readwrite( "idVolume", &formatMBIN::bintetrahedre::idVolume, "" );
        pyplusplus::containers::static_sized::register_array_1< int, 4 >( "__array_1_int_4" );
        { //formatMBIN::bintetrahedre::sommets [variable], type=formatMBIN::Intb[4]
        
            typedef pyplusplus::containers::static_sized::array_1_t< int, 4> ( *array_wrapper_creator )( ::formatMBIN::bintetrahedre & );
            
            bintetrahedre_exposer.add_property( "sommets"
                , bp::make_function( array_wrapper_creator(&bintetrahedre_wrapper::pyplusplus_sommets_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() )
            , "" );
        }
        pyplusplus::containers::static_sized::register_array_1< ::formatMBIN::bintetraface, 4, bp::return_internal_reference< > >( "__array_1__scope_formatMBIN_scope_bintetraface_4" );
        { //formatMBIN::bintetrahedre::tetrafaces [variable], type=formatMBIN::bintetraface[4]
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::formatMBIN::bintetraface, 4> ( *array_wrapper_creator )( ::formatMBIN::bintetrahedre & );
            
            bintetrahedre_exposer.add_property( "tetrafaces"
                , bp::make_function( array_wrapper_creator(&bintetrahedre_wrapper::pyplusplus_tetrafaces_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() )
            , "" );
        }
    }

    { //::formatMBIN::t_binNode
        typedef bp::class_< t_binNode_wrapper > t_binNode_exposer_t;
        t_binNode_exposer_t t_binNode_exposer = t_binNode_exposer_t( "t_binNode", "", bp::init< >("") );
        bp::scope t_binNode_scope( t_binNode_exposer );
        t_binNode_exposer.def( bp::init< formatMBIN::Floatb const &, formatMBIN::Floatb const &, formatMBIN::Floatb const & >(( bp::arg("x"), bp::arg("y"), bp::arg("z") ), "") );
        t_binNode_exposer.def( bp::self == bp::self );
        pyplusplus::containers::static_sized::register_array_1< float, 3 >( "__array_1_float_3" );
        { //formatMBIN::t_binNode::node [variable], type=formatMBIN::Floatb[3]
        
            typedef pyplusplus::containers::static_sized::array_1_t< float, 3> ( *array_wrapper_creator )( ::formatMBIN::t_binNode & );
            
            t_binNode_exposer.add_property( "node"
                , bp::make_function( array_wrapper_creator(&t_binNode_wrapper::pyplusplus_node_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() )
            , "" );
        }
    }

    bp::class_< formatMBIN::trimeshmodel >( "trimeshmodel", "" )    
        .def_readwrite( "nodes", &formatMBIN::trimeshmodel::nodes, "" )    
        .def_readwrite( "tetrahedres", &formatMBIN::trimeshmodel::tetrahedres, "" );

    bp::class_< formatRSBIN::rsurf_data >( "rsurf_data", "", bp::init< >("") )    
        .def( 
            "ComputeFaceArea"
            , (float ( ::formatRSBIN::rsurf_data::* )( ::size_t const &,::size_t const & ) )( &::formatRSBIN::rsurf_data::ComputeFaceArea )
            , ( bp::arg("rsIndex"), bp::arg("faceIndex") )
            , "Calcul laire dune surface\nParam:[in] rsIndex Indice du récepteur de surface\nParam:[in] faceIndex Indice de la surface\nRetourne Aire de la surface en m²\n" )    
        .def( 
            "GetFaceEnergy"
            , (boost::python::tuple (*)( ::formatRSBIN::rsurf_data const &,::size_t const &,::size_t const &,::size_t const & ))( &GetFaceEnergy_55c09b76319b542d67de8263861c1e72 )
            , ( bp::arg("inst"), bp::arg("rsIndex"), bp::arg("faceIndex"), bp::arg("recordIndex") )
            , "Accesseur Information sur un enregistrement dune face\nParam:[in] rsIndex Indice du récepteur de surface\nParam:[in] faceIndex Indice de la surface\nParam:[in] recordIndex Indice de lenregistrement\nParam:[out] idstep Compteur du pas de temps\nParam:[out] energy Energie(w) ou temps(s)\n@python Return a tuple containing (idstep,energy)\n" )    
        .def( 
            "GetFaceInfo"
            , (boost::python::tuple (*)( ::formatRSBIN::rsurf_data const &,::size_t const &,::size_t const & ))( &GetFaceInfo_ffd41391329802f344cde7ce4f2494dc )
            , ( bp::arg("inst"), bp::arg("rsIndex"), bp::arg("faceIndex") )
            , "Accesseur Information sur une face\nParam:[in] rsIndex Indice du récepteur de surface\nParam:[in] faceIndex Indice de la surface\nParam:[out] vertexA Indice du sommet\nParam:[out] vertexB Indice du sommet\nParam:[out] vertexC Indice du sommet\nParam:[out] recordCount Nombre denregistrement\n@python Return a tuple containing ( vertexA,vertexB,vertexC,recordCount)\n" )    
        .def( 
            "GetFaceSumEnergy"
            , (float ( ::formatRSBIN::rsurf_data::* )( ::size_t const &,::size_t const & ) )( &::formatRSBIN::rsurf_data::GetFaceSumEnergy )
            , ( bp::arg("rsIndex"), bp::arg("faceIndex") )
            , "Accesseur Information sur un enregistrement dune face\nParam:[in] rsIndex Indice du récepteur de surface\nParam:[in] faceIndex Indice de la surface\nRetourne Energie cumulé (w) ou temps (s)\n" )    
        .def( 
            "GetFileInfos"
            , (boost::python::tuple (*)( ::formatRSBIN::rsurf_data const & ))( &GetFileInfos_525a3be9f8f575bd95315a87170ba40a )
            , ( bp::arg("inst") )
            , "Accesseur propriétés du fichier\nParam:[out] rs_size Nombre de sommets de triangles\nParam:[out] nodes_size Nombre de récepteurs de surfaces\nParam:[out] nbtimestep Nombre de pas de temps maximum\nParam:[out] timestep Pas de temps en secondes\nParam:[out] record_type Type denregistrement. Valeurs possibles SPL_STANDART SPL_GAIN TR EDT\n@python Return a tuple containing (rs_size,nodes_size,nbtimestep,timestep,recordType)\n" )    
        .def( 
            "GetNodePositionValue"
            , (boost::python::tuple (*)( ::formatRSBIN::rsurf_data const &,::size_t const & ))( &GetNodePositionValue_69e14843c7ed97ad3f492e0c41cf7a26 )
            , ( bp::arg("inst"), bp::arg("nodeIndex") )
            , "Accesseur valeur dun noeud\nParam:[in] nodeIndex Indice du sommet\nParam:[out] x X\nParam:[out] y Y\nParam:[out] z Z\n@python Return a tuple containing (x,y,z)\n" )    
        .def( 
            "GetRsCount"
            , (::size_t ( ::formatRSBIN::rsurf_data::* )(  ) )( &::formatRSBIN::rsurf_data::GetRsCount )
            , "Retourne le nombre de récepteur surfaciques.\n" )    
        .def( 
            "GetRsInfo"
            , (boost::python::tuple (*)( ::formatRSBIN::rsurf_data const &,::size_t const & ))( &GetRsInfo_a448d76a66bcf1e5144f7f8c9f8afdd9 )
            , ( bp::arg("inst"), bp::arg("rsIndex") )
            , "Accesseur Information sur un recepteur surfacique\nParam:[in] rsIndex Indice du récepteur de surface\nParam:[out] nbfaces Nombre de surfaces\nParam:[out] rs_name Libellé du récepteur de surface\nParam:[out] xmlid Indice xml du récepteur\n@python Return a tuple containing (nbfaces,rs_name,xmlid)\n" )    
        .def( 
            "Make"
            , (void ( ::formatRSBIN::rsurf_data::* )( ::size_t const &,::size_t const &,int const &,float const &,::std::string const & ) )( &::formatRSBIN::rsurf_data::Make )
            , ( bp::arg("tabNodesSize"), bp::arg("tabRsSize"), bp::arg("nbtimestep"), bp::arg("timestep"), bp::arg("record_type")="SPL_STANDART" )
            , "1ere étape Création, Mise en place des récepteurs et des propriétés\nParam:[in] tabNodesSize Nombre de sommets de triangles\nParam:[in] tabRsSize Nombre de récepteurs de surfaces\nParam:[in] nbtimestep Nombre de pas de temps maximum\nParam:[in] timestep Pas de temps en secondes\nParam:[in] record_type Type denregistrement. Valeurs possibles SPL_STANDART SPL_GAIN TR EDT\n" )    
        .def( 
            "MakeRs"
            , (void ( ::formatRSBIN::rsurf_data::* )( ::size_t const &,::size_t const &,::std::string const &,int const & ) )( &::formatRSBIN::rsurf_data::MakeRs )
            , ( bp::arg("rsIndex"), bp::arg("nbfacesconst"), bp::arg("rs_name"), bp::arg("xmlid") )
            , "2eme étape Création, Affectation des propriétés dun récepteur\nParam:[in] rsIndex Indice du récepteur surfacique\nParam:[in] nbfacesconst Nombre de faces dans ce récepteur de surfaces.\nParam:[in] rs_name Nom du récepteur de surface\nParam:[in] xmlid Indice XML du récepteur de surface\n" )    
        .def( 
            "SetFaceEnergy"
            , (void ( ::formatRSBIN::rsurf_data::* )( ::size_t const &,::size_t const &,::size_t const &,::size_t const &,float const & ) )( &::formatRSBIN::rsurf_data::SetFaceEnergy )
            , ( bp::arg("rsIndex"), bp::arg("faceIndex"), bp::arg("recordIndex"), bp::arg("idstep"), bp::arg("energy") )
            , "4eme étape Création, Affectation de la valeur de pression dun pas de temps sur une face\nParam:[in] rsIndex Indice du récepteur de surface\nParam:[in] faceIndex Indice de la face\nParam:[in] recordIndex Indice de lenregistrement\nParam:[in] idstep xeme pas de temps ( x=y sectimestep )\nParam:[in] energy Niveau de pression (SPL) ou temps (TR EDT)\n" )    
        .def( 
            "SetFaceInfo"
            , (void ( ::formatRSBIN::rsurf_data::* )( ::size_t const &,::size_t const &,::size_t const &,::size_t const &,::size_t const &,::size_t const & ) )( &::formatRSBIN::rsurf_data::SetFaceInfo )
            , ( bp::arg("rsIndex"), bp::arg("faceIndex"), bp::arg("vertexA"), bp::arg("vertexB"), bp::arg("vertexC"), bp::arg("recordCount") )
            , "3eme étape Création, Affectation des propriétés dune face\nParam:[in] rsIndex Indice du récepteur de surface\nParam:[in] faceIndex Indice de la face\nParam:[in] vertexA Indice du sommet\nParam:[in] vertexB Indice du sommet\nParam:[in] vertexC Indice du sommet\nParam:[in] recordCount Nombre denregistrements de niveaux (energy=0)\n" )    
        .def( 
            "SetNodeValue"
            , (void ( ::formatRSBIN::rsurf_data::* )( ::size_t const &,float const &,float const &,float const & ) )( &::formatRSBIN::rsurf_data::SetNodeValue )
            , ( bp::arg("nodeIndex"), bp::arg("x"), bp::arg("y"), bp::arg("z") )
            , "2eme étape Création, Affectation de la valeur dun noeud\nParam:[in] nodeIndex Indice du sommet\nParam:[in] x Position X (m)\nParam:[in] y Position Y (m)\nParam:[in] z Position Z (m)\n" );

    bp::class_< formatRSBIN::rsurf_io >( "rsurf_io", "", bp::init< >("") )    
        .def( 
            "Load"
            , (bool (*)( ::std::string const &,::formatRSBIN::rsurf_data & ))( &::formatRSBIN::rsurf_io::Load )
            , ( bp::arg("fileName"), bp::arg("data") )
            , "" )    
        .def( 
            "Save"
            , (bool (*)( ::std::string const &,::formatRSBIN::rsurf_data & ))( &::formatRSBIN::rsurf_io::Save )
            , ( bp::arg("fileName"), bp::arg("data") )
            , "" )    
        .staticmethod( "Load" )    
        .staticmethod( "Save" );

    bp::class_< formatRSBIN::rsurf_iso_contouring >( "rsurf_iso_contouring", "", bp::init< formatRSBIN::rsurf_data const &, size_t const & >(( bp::arg("data"), bp::arg("rsIndex") ), "~english\nIso Contouring initialisation step.\n") )    
        .def( 
            "GetIsoLevelCurves"
            , (boost::python::object (*)( ::formatRSBIN::rsurf_iso_contouring &,float const & ))( &GetIsoLevelCurves_0b820db76235dcaa6b487d6859dceb78 )
            , ( bp::arg("inst"), bp::arg("isolvl") )
            , "Calcul la position de segments\n" )    
        .def( 
            "GetMinMax"
            , (boost::python::tuple (*)( ::formatRSBIN::rsurf_iso_contouring & ))( &GetMinMax_e4c8ac6649065b317c0a2384fc05fbe2 )
            , ( bp::arg("inst") )
            , "Retourne les valeurs min,max\n" )    
        .def( 
            "SmoothGrid"
            , (void ( ::formatRSBIN::rsurf_iso_contouring::* )( int const & ) )( &::formatRSBIN::rsurf_iso_contouring::SmoothGrid )
            , ( bp::arg("smoothcount") )
            , "Afin de lisser les isocourbes on peut multiplier le nombre de triangle et interpoler la valeur des nouveaux sommets.\nParam: smoothcount Nombre de subdivision de la grille.\n" );

    { //::formatRSBIN::t_curve
        typedef bp::class_< t_curve_wrapper > t_curve_exposer_t;
        t_curve_exposer_t t_curve_exposer = t_curve_exposer_t( "t_curve", "" );
        bp::scope t_curve_scope( t_curve_exposer );
        pyplusplus::containers::static_sized::register_array_1< float, 3 >( "__array_1_float_3" );
        { //formatRSBIN::t_curve::A [variable], type=formatRSBIN::t_pos
        
            typedef pyplusplus::containers::static_sized::array_1_t< float, 3> ( *array_wrapper_creator )( ::formatRSBIN::t_curve & );
            
            t_curve_exposer.add_property( "A"
                , bp::make_function( array_wrapper_creator(&t_curve_wrapper::pyplusplus_A_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() )
            , "" );
        }
        { //formatRSBIN::t_curve::B [variable], type=formatRSBIN::t_pos
        
            typedef pyplusplus::containers::static_sized::array_1_t< float, 3> ( *array_wrapper_creator )( ::formatRSBIN::t_curve & );
            
            t_curve_exposer.add_property( "B"
                , bp::make_function( array_wrapper_creator(&t_curve_wrapper::pyplusplus_B_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() )
            , "" );
        }
    }

    { //::gabe_io::Gabe_rw
        typedef bp::class_< gabe_io::Gabe_rw > Gabe_rw_exposer_t;
        Gabe_rw_exposer_t Gabe_rw_exposer = Gabe_rw_exposer_t( "Gabe_rw", "", bp::init< size_t const & >(( bp::arg("sizeHint") ), "Param: sizeHint A la génération dun tableau ce paramètre permet une plus grand rapiditée dajout des colonnes\n") );
        bp::scope Gabe_rw_scope( Gabe_rw_exposer );
        bp::implicitly_convertible< size_t const &, gabe_io::Gabe_rw >();
        Gabe_rw_exposer.def( bp::init< >("") );
        { //::gabe_io::Gabe_rw::AppendFloatCol
        
            typedef void ( ::gabe_io::Gabe_rw::*AppendFloatCol_function_type )( ::gabe_io::floatarray const &,::std::string const &,int const & ) ;
            
            Gabe_rw_exposer.def( 
                "AppendFloatCol"
                , AppendFloatCol_function_type( &::gabe_io::Gabe_rw::AppendFloatCol )
                , ( bp::arg("coldata"), bp::arg("coltitle"), bp::arg("precision")=12 )
                , "Ajoute une colonne de nombres flottants à la fin du tableau\n" );
        
        }
        { //::gabe_io::Gabe_rw::AppendIntCol
        
            typedef void ( ::gabe_io::Gabe_rw::*AppendIntCol_function_type )( ::gabe_io::intarray const &,::std::string const & ) ;
            
            Gabe_rw_exposer.def( 
                "AppendIntCol"
                , AppendIntCol_function_type( &::gabe_io::Gabe_rw::AppendIntCol )
                , ( bp::arg("coldata"), bp::arg("coltitle") )
                , "Ajoute une colonne dentier à la fin du tableau\n" );
        
        }
        { //::gabe_io::Gabe_rw::AppendStrCol
        
            typedef void ( ::gabe_io::Gabe_rw::*AppendStrCol_function_type )( ::gabe_io::stringarray const &,::std::string const & ) ;
            
            Gabe_rw_exposer.def( 
                "AppendStrCol"
                , AppendStrCol_function_type( &::gabe_io::Gabe_rw::AppendStrCol )
                , ( bp::arg("coldata"), bp::arg("coltitle") )
                , "Ajoute une colonne de chaine de caractères à la fin du tableau\n" );
        
        }
        { //::gabe_io::Gabe_rw::GetColTitle
        
            typedef ::std::string ( ::gabe_io::Gabe_rw::*GetColTitle_function_type )( ::size_t const & ) ;
            
            Gabe_rw_exposer.def( 
                "GetColTitle"
                , GetColTitle_function_type( &::gabe_io::Gabe_rw::GetColTitle )
                , ( bp::arg("idcol") )
                , "Lecture du titre dune colonne\n" );
        
        }
        { //::gabe_io::Gabe_rw::GetTabTypes
        
            typedef ::gabe_io::typearray ( ::gabe_io::Gabe_rw::*GetTabTypes_function_type )(  ) ;
            
            Gabe_rw_exposer.def( 
                "GetTabTypes"
                , GetTabTypes_function_type( &::gabe_io::Gabe_rw::GetTabTypes )
                , "Retourne les types de données sur les colonnes\n" );
        
        }
        { //::gabe_io::Gabe_rw::IsReadOnly
        
            typedef bool ( ::gabe_io::Gabe_rw::*IsReadOnly_function_type )(  ) ;
            
            Gabe_rw_exposer.def( 
                "IsReadOnly"
                , IsReadOnly_function_type( &::gabe_io::Gabe_rw::IsReadOnly )
                , "Les données sont elles en lecture seule pour lutilisateur.\n" );
        
        }
        { //::gabe_io::Gabe_rw::Load
        
            typedef bool ( ::gabe_io::Gabe_rw::*Load_function_type )( ::std::string const & ) ;
            
            Gabe_rw_exposer.def( 
                "Load"
                , Load_function_type( &::gabe_io::Gabe_rw::Load )
                , ( bp::arg("fileName") )
                , "Chargement du tableau\nParam: strFileName Chemin du fichier\n" );
        
        }
        { //::gabe_io::Gabe_rw::ReadColFloat
        
            typedef boost::python::object ( *ReadColFloat_function_type )( ::gabe_io::Gabe_rw &,::size_t const & );
            
            Gabe_rw_exposer.def( 
                "ReadColFloat"
                , ReadColFloat_function_type( &ReadColFloat_2d7d953196ad1599f64a7b62cd706458 )
                , ( bp::arg("inst"), bp::arg("idcol") )
                , "Lecture dune colonne sous forme de chaine de caractère\n@warning Si cet indice ne correspond pas à une colonne de ce type alors cette méthode naffectera pas le paramètre en entrée et ne lévera pas derreur.\n@python The coldata paramemeter is returned by this function.\n" );
        
        }
        { //::gabe_io::Gabe_rw::ReadColInt
        
            typedef boost::python::object ( *ReadColInt_function_type )( ::gabe_io::Gabe_rw &,::size_t const & );
            
            Gabe_rw_exposer.def( 
                "ReadColInt"
                , ReadColInt_function_type( &ReadColInt_a923d984c4b477c9ce588113f8089b93 )
                , ( bp::arg("inst"), bp::arg("idcol") )
                , "Lecture dune colonne sous forme de chaine de caractère\n@warning Si cet indice ne correspond pas à une colonne de ce type alors cette méthode naffectera pas le paramètre en entrée et ne lévera pas derreur.\n@python The coldata paramemeter is returned by this function.\n" );
        
        }
        { //::gabe_io::Gabe_rw::ReadColStr
        
            typedef boost::python::object ( *ReadColStr_function_type )( ::gabe_io::Gabe_rw &,::size_t const & );
            
            Gabe_rw_exposer.def( 
                "ReadColStr"
                , ReadColStr_function_type( &ReadColStr_0f0439e36e04578028500fb87bbc9ea3 )
                , ( bp::arg("inst"), bp::arg("idcol") )
                , "Lecture dune colonne sous forme de chaine de caractère, nechoue jamais\n@python The coldata paramemeter is returned by this function.\n" );
        
        }
        { //::gabe_io::Gabe_rw::Save
        
            typedef bool ( ::gabe_io::Gabe_rw::*Save_function_type )( ::std::string const & ) ;
            
            Gabe_rw_exposer.def( 
                "Save"
                , Save_function_type( &::gabe_io::Gabe_rw::Save )
                , ( bp::arg("fileName") )
                , "Sauvegarde du tableau\nParam: strFileName Chemin du fichier\n" );
        
        }
        { //::gabe_io::Gabe_rw::SetReadOnly
        
            typedef void ( ::gabe_io::Gabe_rw::*SetReadOnly_function_type )( bool const & ) ;
            
            Gabe_rw_exposer.def( 
                "SetReadOnly"
                , SetReadOnly_function_type( &::gabe_io::Gabe_rw::SetReadOnly )
                , ( bp::arg("ReadOnly")=true )
                , "Change le mode dédition par lutilisateur dans linterface\n" );
        
        }
        { //::gabe_io::Gabe_rw::operator[]
        
            typedef ::gabe_io::stringarray ( ::gabe_io::Gabe_rw::*__getitem___function_type )( ::size_t ) ;
            
            Gabe_rw_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::gabe_io::Gabe_rw::operator[] )
                , ( bp::arg("indicecol") )
                , "Lire une colonne en tant que chaine de caractères (compatible avec nimporte quel type de colonne)\n" );
        
        }
        { //::gabe_io::Gabe_rw::size
        
            typedef ::size_t ( ::gabe_io::Gabe_rw::*__len___function_type )(  ) const;
            
            Gabe_rw_exposer.def( 
                "__len__"
                , __len___function_type( &::gabe_io::Gabe_rw::size )
                , "Retourne Nombre de colonnes\n@python Use the len function to give the number of cols.\n" );
        
        }
    }

    bp::class_< particleio::ParticuleIO >( "ParticuleIO", "", bp::init< >("") )    
        .def( 
            "Close"
            , (void ( ::particleio::ParticuleIO::* )(  ) )( &::particleio::ParticuleIO::Close )
            , "Fermeture du fichier\nCette méthode est automatiquement appelé lors de la destruction de linstance de ParticuleIO\n" )    
        .def( 
            "GetHeaderData"
            , (boost::python::tuple (*)( ::particleio::ParticuleIO & ))( &GetHeaderData_22ac753966e05a8aaaebdeb7d63f0bed )
            , ( bp::arg("inst") )
            , "Permet daccéder aux données dentête du fichier de particule\nParam:[out] timeStep Pas de temps en seconde\nParam:[out] nbParticles Nombre de particules\nParam:[out] nbTimeStep Nombre de particules\n@python Return a tuple containing (timeStep,nbParticles,nbStepMax)\n" )    
        .def( 
            "NewParticle"
            , (void ( ::particleio::ParticuleIO::* )( long unsigned int const & ) )( &::particleio::ParticuleIO::NewParticle )
            , ( bp::arg("firsttimestep") )
            , "Enregistre une nouvelle particule\n" )    
        .def( 
            "NewPositionParticle"
            , (void ( ::particleio::ParticuleIO::* )( float const &,float const &,float const &,float const & ) )( &::particleio::ParticuleIO::NewPositionParticle )
            , ( bp::arg("x"), bp::arg("y"), bp::arg("z"), bp::arg("energy") )
            , "Enregistre une nouvelle position pour la particule courante\nParam: x Position\nParam: y Position\nParam: z Position\nParam: energy Energie w\n" )    
        .def( 
            "NextParticle"
            , (boost::python::tuple (*)( ::particleio::ParticuleIO & ))( &NextParticle_3634bdc7fe706d56792b926e84e164fb )
            , ( bp::arg("inst") )
            , "Passe à la prochaine particule\nParam:[out] firstTimeStep Premier pas de temps\nParam:[out] nbTimeStep Nombre de pas de temps\n@python Return a tuple containing (firstTimeStep,nbTimeStep)\n" )    
        .def( 
            "NextTimeStep"
            , (boost::python::tuple (*)( ::particleio::ParticuleIO & ))( &NextTimeStep_5264ddf1ca6388c651910d6ab7422e21 )
            , ( bp::arg("inst") )
            , "Lis une nouvelle position pour la particule courante\nParam:[out] x Position\nParam:[out] y Position\nParam:[out] z Position\nParam:[out] energy Energie w\n@python Return a tuple containing (x,y,z,energy)\n" )    
        .def( 
            "OpenForRead"
            , (bool ( ::particleio::ParticuleIO::* )( ::std::string const & ) )( &::particleio::ParticuleIO::OpenForRead )
            , ( bp::arg("fileName") )
            , "@defgroup methodreadpart Lecture dun fichier de particule\nCes méthodes permettent de lire un fichier de particule\n@{\nLecture dun fichier de particule\nParam: fileName Chemin daccès au fichier de particule\n" )    
        .def( 
            "OpenForWrite"
            , (bool ( ::particleio::ParticuleIO::* )( ::std::string const & ) )( &::particleio::ParticuleIO::OpenForWrite )
            , ( bp::arg("fileName") )
            , "@defgroup methodwritepart Ecriture dun fichier de particule\nCes méthodes permettent de créer un nouveau fichier de particule\n@{\n" )    
        .def( 
            "SetHeaderData"
            , (void ( ::particleio::ParticuleIO::* )( float const & ) )( &::particleio::ParticuleIO::SetHeaderData )
            , ( bp::arg("timeStep") )
            , "Met à jour les données de lentete du fichier\nParam: timeStep Pas de temps en seconde\n" );

    bp::class_< progressOperation >( "progressOperation", "", bp::init< progressOperation *, bp::optional< unsigned int > >(( bp::arg("parentOperation"), bp::arg("sonEstimation")=(unsigned int)(1) ), "Constructeur\n") )    
        .def( 
            "Next"
            , (void ( ::progressOperation::* )(  ) )( &::progressOperation::Next )
            , "" );

    { //::progressionInfo
        typedef bp::class_< progressionInfo > progressionInfo_exposer_t;
        progressionInfo_exposer_t progressionInfo_exposer = progressionInfo_exposer_t( "progressionInfo", "", bp::init< int >(( bp::arg("firstLevelEstimation") ), "Constructeur\nParam: firstLevelEstimation Nombre de tache au premier niveau hiérarchique de taches\n") );
        bp::scope progressionInfo_scope( progressionInfo_exposer );
        bp::implicitly_convertible< int, progressionInfo >();
        { //::progressionInfo::GetCurrentProgression
        
            typedef float ( ::progressionInfo::*GetCurrentProgression_function_type )(  ) ;
            
            progressionInfo_exposer.def( 
                "GetCurrentProgression"
                , GetCurrentProgression_function_type( &::progressionInfo::GetCurrentProgression )
                , "" );
        
        }
        { //::progressionInfo::GetMainOperation
        
            typedef ::progressOperation * ( ::progressionInfo::*GetMainOperation_function_type )(  ) ;
            
            progressionInfo_exposer.def( 
                "GetMainOperation"
                , GetMainOperation_function_type( &::progressionInfo::GetMainOperation )
                , bp::return_internal_reference< >()
                , "Retourne Loperation principale.\n" );
        
        }
        { //::progressionInfo::OutputCurrentProgression
        
            typedef void ( ::progressionInfo::*OutputCurrentProgression_function_type )(  ) ;
            
            progressionInfo_exposer.def( 
                "OutputCurrentProgression"
                , OutputCurrentProgression_function_type( &::progressionInfo::OutputCurrentProgression )
                , "Affiche la progression si celle-ci a changé\n" );
        
        }
    }

    bp::class_< surf_merge::SurfaceMerging >( "SurfaceMerging", "", bp::init< >("") )    
        .def( 
            "GetGroupInformation"
            , (boost::python::object (*)( ::surf_merge::SurfaceMerging &,unsigned int const & ))( &GetGroupInformation_473f95957775c7bfc40d6c2fd58b23d3 )
            , ( bp::arg("inst"), bp::arg("idel") )
            , "Donne les données pour un groupe\nParam:[in] idel Indice du groupe [0-GetGroups()[\nParam:[out] faceIds Faces du groupe\n@python Return faceIds vector, use list(SurfaceMerging::GetGroupInformation(idel)) python built-in function to translate into an integer list.\n" )    
        .def( 
            "GetGroups"
            , (int ( ::surf_merge::SurfaceMerging::* )(  ) )( &::surf_merge::SurfaceMerging::GetGroups )
            , "Retourne le nombre de groupes de surfaces détectés\n" )    
        .def( 
            "LoadGroups"
            , (void ( ::surf_merge::SurfaceMerging::* )( ::formatCoreBIN::ioModel const & ) )( &::surf_merge::SurfaceMerging::LoadGroups )
            , ( bp::arg("model") )
            , "Lectures des structures de données à la recherche des faces coplanaires\nParam: model Modèle de la scène\n" )    
        .def( 
            "SavePolyToPolyFile"
            , (void ( ::surf_merge::SurfaceMerging::* )( char const * ) )( &::surf_merge::SurfaceMerging::SavePolyToPolyFile )
            , ( bp::arg("strFileName") )
            , "Sauvegarde les triangles fusionnés dans le format de fichier .poly\nParam: strFileName Nom et chemin du fichier de sortie\n" );

    bp::class_< volumes_splitter::VolumesSplitter >( "VolumesSplitter", "", bp::init< >("") )    
        .def( 
            "GetInternalFaces"
            , (boost::python::object (*)( ::volumes_splitter::VolumesSplitter &,int const & ))( &GetInternalFaces_fbc0fddf6ae8bebef1d097a04f650254 )
            , ( bp::arg("inst"), bp::arg("volumeXmlIdFilter")=-0x000000001 )
            , "Retourne la liste des limites internes (faces ayant un volume de chaque coté\nParam:[out] internalFaceIds Faces propre au volume\nParam:[int] volumeXmlIdFilter Limiter les faces internes appartenant à ce volume (-1 aucun filtre)\n@python Return internalFaceIds\n" )    
        .def( 
            "GetTetraByPosition"
            , (int ( ::volumes_splitter::VolumesSplitter::* )( ::formatMBIN::trimeshmodel const &,float const &,float const &,float const &,bool const & ) )( &::volumes_splitter::VolumesSplitter::GetTetraByPosition )
            , ( bp::arg("tetramodel"), bp::arg("x"), bp::arg("y"), bp::arg("z"), bp::arg("reloadTetraModel")=false )
            , "english Find the tetrahedron that contains the point specified at parameters\nAttention: You dont have to call LoadDomain before using this function but you must always use the same tetramodel with the same VolumesSplitter instance.\nParam: tetramodel Scene tetra mesh.\nParam: x Position in local coordinate system\nParam: y Position in local coordinate system\nParam: z Position in local coordinate system\nParam: reloadTetraModel Reload the position test array from the first parameter.Set it to true if you have modified the first parameter between two call of GetTetraByPosition.\nRetourne The tetrahedron index if found or -1 if not found.\nfrench Cherche la tétraèdre contenant le point indiqué en paramètre.\nAttention: Il nest pas nécessaire dappeler la méthode LoadDomain avant dutiliser cette fonction\nParam: tetramodel Maillage de la scène\nParam: x Position\nParam: y Position\nParam: z Position\nParam: reloadTetraModel Recharge le premier paramètre dans la table de test de position. Mettez le à vrai si vous avez modifié la structure tetramodel entre deux appel de GetTetraByPosition.\nRetourne Lindice du tetraèdre ou -1 si non trouvé.\n" )    
        .def( 
            "__getitem__"
            , (boost::python::tuple (*)( ::volumes_splitter::VolumesSplitter &,int const & ))( &GetVolumeInformation_1c18ff1b84a2763e89ab8ac465e1d8ad )
            , ( bp::arg("inst"), bp::arg("idel") )
            , "Donne les données pour un volume\nParam:[in] idel Indice du volume [0-GetVolumes()[\nParam:[out] volumeXmlId Indice Xml du volume\nParam:[out] volume Volume (m3)\nParam:[out] faceIds Faces propre au volume\nParam:[out] volNeigh Volumes voisins du volume idel\n@python Read through VolumesSplitterInstance[volid] and return a tuple containing (volumeXmlId,volume,faceIds,volNeigh)\n" )    
        .def( 
            "GetVolumeXmlId"
            , (int ( ::volumes_splitter::VolumesSplitter::* )( int const & ) )( &::volumes_splitter::VolumesSplitter::GetVolumeXmlId )
            , ( bp::arg("idel") )
            , "Donne lIndice Xml du volume\nParam:[in] idel Indice du volume [0-GetVolumes()[\nRetourne Indice Xml du volume\n" )    
        .def( 
            "__len__"
            , (int ( ::volumes_splitter::VolumesSplitter::* )(  ) )( &::volumes_splitter::VolumesSplitter::GetVolumes )
            , "Retourne le nombre de volumes détectés\n@python Read through len(VolumesSplitterInstance)\n" )    
        .def( 
            "LoadDomain"
            , (void ( ::volumes_splitter::VolumesSplitter::* )( ::formatCoreBIN::ioModel const &,::formatMBIN::trimeshmodel const & ) )( &::volumes_splitter::VolumesSplitter::LoadDomain )
            , ( bp::arg("model"), bp::arg("tetramodel") )
            , "Lectures des structures de données à la recherche des volumes\nParam: model Modèle de la scène\nParam: tetramodel Maillage de la scène\n" );
}
